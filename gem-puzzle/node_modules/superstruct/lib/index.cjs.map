{"version":3,"file":"index.cjs","sources":["../src/utils.ts","../src/struct.ts","../src/coercions.ts","../src/refinements.ts","../src/types.ts"],"sourcesContent":["import { Struct, StructResult, StructFailure, StructContext } from './struct'\n\nexport type StructRecord<T> = Record<string, Struct<T>>\nexport type StructTuple<T> = { [K in keyof T]: Struct<T[K]> }\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function toFailures(\n  result: StructResult,\n  context: StructContext\n): Iterable<StructFailure> {\n  if (result === true) {\n    return []\n  } else if (result === false) {\n    return [context.fail()]\n  } else {\n    return result\n  }\n}\n","import { toFailures } from './utils'\n\n/**\n * `Struct` objects encapsulate the schema for a specific data type (with\n * optional coercion). You can then use the `assert`, `is` or `validate` helpers\n * to validate unknown data against a struct.\n */\n\nexport class Struct<T, S = any> {\n  type: string\n  schema: S\n  coercer: (value: unknown) => unknown\n  validator: (value: unknown, context: StructContext) => StructResult\n  refiner: (value: T, context: StructContext) => StructResult\n\n  constructor(props: {\n    type: Struct<T>['type']\n    schema: S\n    coercer?: Struct<T>['coercer']\n    validator?: Struct<T>['validator']\n    refiner?: Struct<T>['refiner']\n  }) {\n    const {\n      type,\n      schema,\n      coercer = (value: unknown) => value,\n      validator = () => [],\n      refiner = () => [],\n    } = props\n    this.type = type\n    this.schema = schema\n    this.coercer = coercer\n    this.validator = validator\n    this.refiner = refiner\n  }\n}\n\n/**\n * `StructError` objects are thrown (or returned) by Superstruct when its\n * validation fails. The error represents the first error encountered during\n * validation. But they also have an `error.failures` property that holds\n * information for all of the failures encountered.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  type: string\n  path: Array<number | string>\n  branch: Array<any>\n  failures: () => Iterable<StructFailure>;\n  [key: string]: any\n\n  constructor(failure: StructFailure, iterable: Iterable<StructFailure>) {\n    const { path, value, type, branch, ...rest } = failure\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n\n    function* failures(): Iterable<StructFailure> {\n      yield failure\n      yield* iterable\n    }\n\n    super(message)\n    this.value = value\n    Object.assign(this, rest)\n    this.type = type\n    this.path = path\n    this.branch = branch\n    this.failures = failures\n    this.stack = new Error().stack\n    ;(this as any).__proto__ = StructError.prototype\n  }\n}\n\n/**\n * A `StructContext` contains information about the current value being\n * validated as well as helper functions for failures and recursive validating.\n */\n\nexport type StructContext = {\n  value: any\n  type: string\n  branch: Array<any>\n  path: Array<string | number>\n  fail: (props?: Partial<StructFailure>) => StructFailure\n  check: (\n    value: any,\n    struct: Struct<any> | Struct<never>,\n    parent?: any,\n    key?: string | number\n  ) => Iterable<StructFailure>\n}\n\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type StructFailure = {\n  value: StructContext['value']\n  type: StructContext['type']\n  branch: StructContext['branch']\n  path: StructContext['path']\n  [key: string]: any\n}\n\n/**\n * A `StructResult` is returned from validation functions.\n */\n\nexport type StructResult = boolean | Iterable<StructFailure>\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type StructType<T extends Struct<any>> = Parameters<T['refiner']>[0]\n\n/**\n * Assert that a value passes a `Struct`, throwing if it doesn't.\n */\n\nexport function assert<T>(\n  value: unknown,\n  struct: Struct<T>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Coerce a value with the coercion logic of `Struct` and validate it.\n */\n\nexport function coerce<T>(value: unknown, struct: Struct<T>): T {\n  const ret = struct.coercer(value)\n  assert(ret, struct)\n  return ret\n}\n\n/**\n * Check if a value passes a `Struct`.\n */\n\nexport function is<T>(value: unknown, struct: Struct<T>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a `Struct`, returning an error if invalid.\n */\n\nexport function validate<T>(\n  value: unknown,\n  struct: Struct<T>,\n  coercing: boolean = false\n): [StructError, undefined] | [undefined, T] {\n  if (coercing) {\n    value = struct.coercer(value)\n  }\n\n  const iterable = check(value, struct)\n  const [failure] = iterable\n\n  if (failure) {\n    const error = new StructError(failure, iterable)\n    return [error, undefined]\n  } else {\n    return [undefined, value as T]\n  }\n}\n\n/**\n * Check a value against a `Struct`, returning an iterable of failures.\n */\n\nfunction* check<T>(\n  value: unknown,\n  struct: Struct<T>,\n  path: any[] = [],\n  branch: any[] = []\n): Iterable<StructFailure> {\n  const { type } = struct\n  const ctx: StructContext = {\n    value,\n    type,\n    branch,\n    path,\n    fail(props = {}) {\n      return { value, type, path, branch: [...branch, value], ...props }\n    },\n    check(v, s, parent, key) {\n      const p = parent !== undefined ? [...path, key] : path\n      const b = parent !== undefined ? [...branch, parent] : branch\n      return check(v, s, p, b)\n    },\n  }\n\n  const failures = toFailures(struct.validator(value, ctx), ctx)\n  const [failure] = failures\n\n  if (failure) {\n    yield failure\n    yield* failures\n  } else {\n    yield* toFailures(struct.refiner(value as T, ctx), ctx)\n  }\n}\n","import { Struct } from './struct'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n */\n\nexport function coercion<T>(\n  struct: Struct<T>,\n  coercer: Struct<T>['coercer']\n): Struct<T> {\n  const fn = struct.coercer\n  return new Struct({\n    ...struct,\n    coercer: (value) => {\n      return fn(coercer(value))\n    },\n  })\n}\n\n/**\n * Augment a struct to coerce a default value for missing values.\n *\n * Note: You must use `coerce(value, Struct)` on the value before validating it\n * to have the value defaulted!\n */\n\nexport function defaulted<T>(\n  S: Struct<T>,\n  fallback: any,\n  strict?: true\n): Struct<T> {\n  return coercion(S, (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (strict !== true && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Coerce a value to mask its properties to only that defined in the struct.\n */\n\nexport function masked<\n  T extends { [key: string]: any },\n  V extends Record<string, Struct<any>>\n>(S: Struct<T, V>): Struct<T> {\n  return coercion(S, (x) => {\n    if (!isPlainObject(x)) {\n      return x\n    }\n\n    const ret: any = {}\n\n    for (const key in S.schema) {\n      ret[key] = x[key]\n    }\n\n    return ret\n  })\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(value: unknown): value is { [key: string]: any } {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n","import { Struct } from './struct'\nimport { toFailures } from './utils'\n\n/**\n * Augment a string or array struct to constrain its length to zero.\n */\n\nexport function empty<T extends string | any[]>(S: Struct<T>): Struct<T> {\n  return refinement(S, `${S.type} & Empty`, (value) => {\n    return value.length === 0\n  })\n}\n\n/**\n * Augment a string or array struct to constrain its length to being between a\n * minimum and maximum size.\n */\n\nexport function length<T extends string | any[]>(\n  S: Struct<T>,\n  min: number,\n  max: number\n): Struct<T> {\n  return refinement(S, `${S.type} & Length<${min},${max}>`, (value) => {\n    return min < value.length && value.length < max\n  })\n}\n\n/**\n * Refine a string struct to match a specific regexp pattern.\n */\n\nexport function pattern<T extends string>(\n  S: Struct<T>,\n  regexp: RegExp\n): Struct<T> {\n  return refinement(S, `${S.type} & Pattern<${regexp.source}>`, (value) => {\n    return regexp.test(value)\n  })\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n */\n\nexport function refinement<T>(\n  struct: Struct<T>,\n  type: string,\n  refiner: Struct<T>['refiner']\n): Struct<T> {\n  const fn = struct.refiner\n  return new Struct({\n    ...struct,\n    type,\n    *refiner(value, fail) {\n      yield* toFailures(fn(value, fail), fail)\n      yield* toFailures(refiner(value, fail), fail)\n    },\n  })\n}\n","import { Struct, StructType, coerce, StructContext } from './struct'\nimport { StructRecord, StructTuple } from './utils'\n\n/**\n * Validate any value.\n */\n\nexport function any(): Struct<any> {\n  return struct('any', () => true)\n}\n\n/**\n * Validate that an array of values of a specific type.\n */\n\nexport function array(): Struct<unknown[]>\nexport function array<T>(Element: Struct<T>): Struct<T[], Struct<T>>\nexport function array<T>(Element?: Struct<T>): any {\n  return new Struct({\n    type: `Array<${Element ? Element.type : 'unknown'}>`,\n    schema: Element,\n    coercer: (value) => {\n      return Element && Array.isArray(value)\n        ? value.map((v) => coerce(v, Element))\n        : value\n    },\n    *validator(value, ctx) {\n      if (!Array.isArray(value)) {\n        yield ctx.fail()\n        return\n      }\n\n      if (Element) {\n        for (const [i, v] of value.entries()) {\n          yield* ctx.check(v, Element, value, i)\n        }\n      }\n    },\n  })\n}\n\n/**\n * Validate that boolean values.\n */\n\nexport function boolean(): Struct<boolean> {\n  return struct('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Validate that `Date` values.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date> {\n  return struct('Date', (value) => {\n    return value instanceof Date && !isNaN(value.getTime())\n  })\n}\n\n/**\n * Validate that a value dynamically, determing which struct to use at runtime.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: StructContext) => Struct<T>\n): Struct<T> {\n  return struct('Dynamic<...>', (value, ctx) => {\n    return ctx.check(value, fn(value, ctx))\n  })\n}\n\n/**\n * Validate that a value against a set of potential values.\n */\n\nexport function enums<T extends number>(values: T[]): Struct<T>\nexport function enums<T extends string>(values: T[]): Struct<T>\nexport function enums<T>(values: T[]): Struct<T> {\n  return struct(`Enum<${values.map(toLiteralString)}>`, (value) => {\n    return values.includes(value as any)\n  })\n}\n\n/**\n * Validate that a value is a function.\n */\n\nexport function func(): Struct<Function> {\n  return struct('Function', (value) => {\n    return typeof value === 'function'\n  })\n}\n\n/**\n * Validate that a value is an instance of a class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>> {\n  return struct(`InstanceOf<${Class.name}>`, (value) => {\n    return value instanceof Class\n  })\n}\n\n/**\n * Validate that a value matches all of a set of structs.\n */\n\nexport function intersection<A>(Structs: StructTuple<[A]>): Struct<A>\nexport function intersection<A, B>(Structs: StructTuple<[A, B]>): Struct<A & B>\nexport function intersection<A, B, C>(\n  Structs: StructTuple<[A, B, C]>\n): Struct<A & B & C>\nexport function intersection<A, B, C, D>(\n  Structs: StructTuple<[A, B, C, D]>\n): Struct<A & B & C & D>\nexport function intersection<A, B, C, D, E>(\n  Structs: StructTuple<[A, B, C, D, E]>\n): Struct<A & B & C & D & E>\nexport function intersection<A, B, C, D, E, F>(\n  Structs: StructTuple<[A, B, C, D, E, F]>\n): Struct<A & B & C & D & E & F>\nexport function intersection<A, B, C, D, E, F, G>(\n  Structs: StructTuple<[A, B, C, D, E, F, G]>\n): Struct<A & B & C & D & E & F & G>\nexport function intersection<A, B, C, D, E, F, G, H>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H]>\n): Struct<A & B & C & D & E & F & G & H>\nexport function intersection<A, B, C, D, E, F, G, H, I>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I]>\n): Struct<A & B & C & D & E & F & G & H & I>\nexport function intersection<A, B, C, D, E, F, G, H, I, J>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A & B & C & D & E & F & G & H & I & J>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q>\nexport function intersection(Structs: Struct<any>[]): any {\n  return struct(Structs.map((s) => s.type).join(' & '), function* (value, ctx) {\n    for (const S of Structs) {\n      yield* ctx.check(value, S)\n    }\n  })\n}\n\n/**\n * Validate a value lazily, by constructing the struct right before the first\n * validation. This is useful for cases where you want to have self-referential\n * structs for nested data structures.\n */\n\nexport function lazy<T>(fn: () => Struct<T>): Struct<T> {\n  let S: Struct<T> | undefined\n\n  return struct('Lazy<...>', (value, ctx) => {\n    if (!S) {\n      S = fn()\n    }\n\n    return ctx.check(value, S)\n  })\n}\n\n/**\n * Validate that a value is a specific constant.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T>\nexport function literal<T extends number>(constant: T): Struct<T>\nexport function literal<T extends string>(constant: T): Struct<T>\nexport function literal<T>(constant: T): Struct<T>\nexport function literal<T>(constant: T): Struct<T> {\n  return struct(`Literal<${toLiteralString(constant)}>`, (value) => {\n    return value === constant\n  })\n}\n\n/**\n * Validate that a value is a map with specific key and value entries.\n */\n\nexport function map<K, V>(Key: Struct<K>, Value: Struct<V>): Struct<Map<K, V>> {\n  return struct(`Map<${Key.type},${Value.type}>`, function* (value, ctx) {\n    if (!(value instanceof Map)) {\n      yield ctx.fail()\n      return\n    }\n\n    for (const [k, v] of value.entries()) {\n      yield* ctx.check(k, Key, value, k)\n      yield* ctx.check(v, Value, value, k)\n    }\n  })\n}\n\n/**\n * Validate that a value always fails.\n */\n\nexport function never(): Struct<never> {\n  return struct('never', () => false)\n}\n\n/**\n * Augment a struct to make it accept `null` values.\n */\n\nexport function nullable<T>(S: Struct<T>): Struct<T | null> {\n  return new Struct({\n    type: `${S.type} | null`,\n    schema: S.schema,\n    validator: (value, ctx) => {\n      return value === null || ctx.check(value, S)\n    },\n  })\n}\n\n/**\n * Validate that a value is a number.\n */\n\nexport function number(): Struct<number> {\n  return struct(`number`, (value) => {\n    return typeof value === 'number' && !isNaN(value)\n  })\n}\n\n/**\n * Type helper to Flatten the Union of optional and required properties.\n */\n\ntype Flatten<T> = T extends infer U ? { [K in keyof U]: U[K] } : never\n\n/**\n * Type helper to extract the optional keys of an object\n */\n\ntype OptionalKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never\n}[keyof T]\n\n/**\n * Type helper to extract the required keys of an object\n */\n\ntype RequiredKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? never : K\n}[keyof T]\n\n/**\n * Type helper to create optional properties when the property value can be\n * undefined (ie. when `optional()` is used to define a type)\n */\n\ntype OptionalizeObject<T> = Flatten<\n  { [K in RequiredKeys<T>]: T[K] } & { [K in OptionalKeys<T>]?: T[K] }\n>\n\n/**\n * Validate that an object with specific entry values.\n */\n\nexport function object<V extends StructRecord<any>>(): Struct<\n  Record<string, unknown>\n>\nexport function object<V extends StructRecord<any>>(\n  Structs: V\n): Struct<OptionalizeObject<{ [K in keyof V]: StructType<V[K]> }>, V>\nexport function object<V extends StructRecord<any>>(\n  Structs?: V\n): Struct<any, any> {\n  const knowns = Structs ? Object.keys(Structs) : []\n  const Never = never()\n  return new Struct({\n    type: Structs ? `Object<{${knowns.join(',')}}>` : 'Object',\n    schema: Structs ? Structs : null,\n    coercer: Structs ? createObjectCoercer(Structs) : (x) => x,\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail()\n        return\n      }\n\n      if (Structs) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          const Value = Structs[key]\n          const v = value[key]\n          yield* ctx.check(v, Value, value, key)\n        }\n\n        for (const key of unknowns) {\n          const v = value[key]\n          yield* ctx.check(v, Never, value, key)\n        }\n      }\n    },\n  })\n}\n\n/**\n * Augment a struct to make it optionally accept `undefined` values.\n */\n\nexport function optional<T>(S: Struct<T>): Struct<T | undefined> {\n  return new Struct({\n    type: `${S.type}?`,\n    schema: S.schema,\n    validator: (value, ctx) => {\n      return value === undefined || ctx.check(value, S)\n    },\n  })\n}\n\n/**\n * Validate that a partial object with specific entry values.\n */\n\nexport function partial<T, V extends StructRecord<any>>(\n  Structs: V | Struct<T, V>\n): Struct<{ [K in keyof V]?: StructType<V[K]> }> {\n  if (Structs instanceof Struct) {\n    Structs = Structs.schema\n  }\n\n  const knowns = Object.keys(Structs)\n  const Never = never()\n  return new Struct({\n    type: `Partial<{${knowns.join(',')}}>`,\n    schema: Structs,\n    coercer: createObjectCoercer(Structs),\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail()\n        return\n      }\n\n      const unknowns = new Set(Object.keys(value))\n\n      for (const key of knowns) {\n        unknowns.delete(key)\n\n        if (!(key in value)) {\n          continue\n        }\n\n        const Value = Structs[key]\n        const v = value[key]\n        yield* ctx.check(v, Value, value, key)\n      }\n\n      for (const key of unknowns) {\n        const v = value[key]\n        yield* ctx.check(v, Never, value, key)\n      }\n    },\n  })\n}\n\n/**\n * Validate that a value is a record with specific key and\n * value entries.\n */\n\nexport function record<K extends string | number, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>> {\n  return struct(`Record<${Key.type},${Value.type}>`, function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail()\n      return\n    }\n\n    for (const k in value) {\n      const v = value[k]\n      yield* ctx.check(k, Key, value, k)\n      yield* ctx.check(v, Value, value, k)\n    }\n  })\n}\n\n/**\n * Validate that a set of values matches a specific type.\n */\n\nexport function set<T>(Element: Struct<T>): Struct<Set<T>> {\n  return struct(`Set<${Element.type}>`, (value, ctx) => {\n    if (!(value instanceof Set)) {\n      return false\n    }\n\n    for (const val of value) {\n      const [failure] = ctx.check(val, Element)\n\n      if (failure) {\n        return false\n      }\n    }\n\n    return true\n  })\n}\n\n/**\n * Validate that a value is a string.\n */\n\nexport function string(): Struct<string> {\n  return struct('string', (value) => {\n    return typeof value === 'string'\n  })\n}\n\n/**\n * Define a `Struct` instance with a type and validation function.\n */\n\nexport function struct<T>(\n  name: string,\n  validator: Struct<T>['validator']\n): Struct<T, null> {\n  return new Struct({ type: name, validator, schema: null })\n}\n\n/**\n * Validate that a value is a tuple with entries of specific types.\n */\n\nexport function tuple<A>(Structs: StructTuple<[A]>): Struct<A>\nexport function tuple<A, B>(Structs: StructTuple<[A, B]>): Struct<[A, B]>\nexport function tuple<A, B, C>(\n  Structs: StructTuple<[A, B, C]>\n): Struct<[A, B, C]>\nexport function tuple<A, B, C, D>(\n  Structs: StructTuple<[A, B, C, D]>\n): Struct<[A, B, C, D]>\nexport function tuple<A, B, C, D, E>(\n  Structs: StructTuple<[A, B, C, D, E]>\n): Struct<[A, B, C, D, E]>\nexport function tuple<A, B, C, D, E, F>(\n  Structs: StructTuple<[A, B, C, D, E, F]>\n): Struct<[A, B, C, D, E, F]>\nexport function tuple<A, B, C, D, E, F, G>(\n  Structs: StructTuple<[A, B, C, D, E, F, G]>\n): Struct<[A, B, C, D, E, F, G]>\nexport function tuple<A, B, C, D, E, F, G, H>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H]>\n): Struct<[A, B, C, D, E, F, G, H]>\nexport function tuple<A, B, C, D, E, F, G, H, I>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I]>\n): Struct<[A, B, C, D, E, F, G, H, I]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<[A, B, C, D, E, F, G, H, I, J]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\nexport function tuple(Elements: Struct<any>[]): any {\n  const Never = never()\n\n  return struct(`[${Elements.map((s) => s.type).join(',')}]`, function* (\n    value,\n    ctx\n  ) {\n    if (!Array.isArray(value)) {\n      yield ctx.fail()\n      return\n    }\n\n    for (const [index, Element] of Elements.entries()) {\n      const v = value[index]\n      yield* ctx.check(v, Element, value, index)\n    }\n\n    if (value.length > Elements.length) {\n      const index = Elements.length\n      const v = value[index]\n      yield* ctx.check(v, Never, value, index)\n    }\n  })\n}\n\n/**\n * Validate that a value matches a specific strutural interface, like the\n * structural typing that TypeScript uses.\n */\n\nexport function type<V extends StructRecord<any>>(\n  Structs: V\n): Struct<{ [K in keyof V]: StructType<V[K]> }> {\n  const keys = Object.keys(Structs)\n\n  return struct(`Type<{${keys.join(',')}}>`, function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail()\n      return\n    }\n\n    for (const key of keys) {\n      const Value = Structs[key]\n      const v = (value as any)[key]\n      yield* ctx.check(v, Value, value, key)\n    }\n  })\n}\n\n/**\n * Validate that a value is one of a set of types.\n */\n\nexport function union<A>(Structs: StructTuple<[A]>): Struct<A>\nexport function union<A, B>(Structs: StructTuple<[A, B]>): Struct<A | B>\nexport function union<A, B, C>(\n  Structs: StructTuple<[A, B, C]>\n): Struct<A | B | C>\nexport function union<A, B, C, D>(\n  Structs: StructTuple<[A, B, C, D]>\n): Struct<A | B | C | D>\nexport function union<A, B, C, D, E>(\n  Structs: StructTuple<[A, B, C, D, E]>\n): Struct<A | B | C | D | E>\nexport function union<A, B, C, D, E, F>(\n  Structs: StructTuple<[A, B, C, D, E, F]>\n): Struct<A | B | C | D | E | F>\nexport function union<A, B, C, D, E, F, G>(\n  Structs: StructTuple<[A, B, C, D, E, F, G]>\n): Struct<A | B | C | D | E | F | G>\nexport function union<A, B, C, D, E, F, G, H>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H]>\n): Struct<A | B | C | D | E | F | G | H>\nexport function union<A, B, C, D, E, F, G, H, I>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I]>\n): Struct<A | B | C | D | E | F | G | H | I>\nexport function union<A, B, C, D, E, F, G, H, I, J>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A | B | C | D | E | F | G | H | I | J>\nexport function union<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q>\nexport function union(Structs: Struct<any>[]): any {\n  return struct(`${Structs.map((s) => s.type).join(' | ')}`, function* (\n    value,\n    ctx\n  ) {\n    for (const S of Structs) {\n      const [...failures] = ctx.check(value, S)\n\n      if (failures.length === 0) {\n        return\n      }\n    }\n\n    yield ctx.fail()\n  })\n}\n\n/**\n * Convert a value to a literal string.\n */\n\nfunction toLiteralString(value: any): string {\n  return typeof value === 'string'\n    ? `\"${value.replace(/\"/g, '\"')}\"`\n    : `${value}`\n}\n\n/**\n * Coerce the values of an object-like struct.\n */\n\nfunction createObjectCoercer<V extends StructRecord<any>>(\n  Structs: V\n): (value: unknown) => unknown {\n  const knowns = Object.keys(Structs)\n\n  return (value) => {\n    if (typeof value !== 'object' || value == null) {\n      return value\n    }\n\n    const ret = {}\n    const unknowns = new Set(Object.keys(value))\n\n    for (const key of knowns) {\n      unknowns.delete(key)\n      const Value = Structs[key]\n      const v = value[key]\n      ret[key] = coerce(v, Value)\n    }\n\n    for (const key of unknowns) {\n      ret[key] = value[key]\n    }\n\n    return ret\n  }\n}\n"],"names":["toFailures","result","context","fail","Struct","constructor","props","type","schema","coercer","value","validator","refiner","StructError","TypeError","failure","iterable","path","branch","rest","message","length","join","JSON","stringify","failures","Object","assign","stack","Error","__proto__","prototype","assert","struct","validate","coerce","ret","is","coercing","check","error","undefined","ctx","v","s","parent","key","p","b","coercion","fn","defaulted","S","fallback","strict","x","f","isPlainObject","changed","masked","toString","call","getPrototypeOf","empty","refinement","min","max","pattern","regexp","source","test","any","array","Element","Array","isArray","map","i","entries","boolean","date","Date","isNaN","getTime","dynamic","enums","values","toLiteralString","includes","func","instance","Class","name","intersection","Structs","lazy","literal","constant","Key","Value","Map","k","never","nullable","number","object","knowns","keys","Never","createObjectCoercer","unknowns","Set","delete","optional","partial","record","set","val","string","tuple","Elements","index","union","replace"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;SAIgBA,WACdC,QACAC;AAEA,MAAID,MAAM,KAAK,IAAf,EAAqB;AACnB,WAAO,EAAP;AACD,GAFD,MAEO,IAAIA,MAAM,KAAK,KAAf,EAAsB;AAC3B,WAAO,CAACC,OAAO,CAACC,IAAR,EAAD,CAAP;AACD,GAFM,MAEA;AACL,WAAOF,MAAP;AACD;AACF;;AClBD;;;;;;MAMaG;AAOXC,EAAAA,YAAYC;AAOV,UAAM;AACJC,MAAAA,IADI;AAEJC,MAAAA,MAFI;AAGJC,MAAAA,OAAO,GAAIC,KAAD,IAAoBA,KAH1B;AAIJC,MAAAA,SAAS,GAAG,MAAM,EAJd;AAKJC,MAAAA,OAAO,GAAG,MAAM;AALZ,QAMFN,KANJ;AAOA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKE,SAAL,GAAiBA,SAAjB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;;AAGH;;;;;;;MAOaC,oBAAoBC;AAQ/BT,EAAAA,YAAYU,SAAwBC;AAClC,UAAM;AAAEC,MAAAA,IAAF;AAAQP,MAAAA,KAAR;AAAeH,MAAAA,IAAf;AAAqBW,MAAAA;AAArB,QAAyCH,OAA/C;AAAA,UAAsCI,IAAtC,4BAA+CJ,OAA/C;;AACA,UAAMK,OAAO,iCAAiCb,SAC5CU,IAAI,CAACI,MAAL,aAAwBJ,IAAI,CAACK,IAAL,CAAU,GAAV,KAAxB,GAA6C,qBAC5BC,IAAI,CAACC,SAAL,CAAed,KAAf,MAFnB;;AAIA,cAAUe,QAAV;AACE,YAAMV,OAAN;AACA,aAAOC,QAAP;AACD;;AAED,UAAMI,OAAN;AACA,SAAKV,KAAL,GAAaA,KAAb;AACAgB,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBR,IAApB;AACA,SAAKZ,IAAL,GAAYA,IAAZ;AACA,SAAKU,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKO,QAAL,GAAgBA,QAAhB;AACA,SAAKG,KAAL,GAAa,IAAIC,KAAJ,GAAYD,KAAzB;AACE,SAAaE,SAAb,GAAyBjB,WAAW,CAACkB,SAArC;AACH;;;AA8CH;;;;SAIgBC,OACdtB,OACAuB;AAEA,QAAMhC,MAAM,GAAGiC,QAAQ,CAACxB,KAAD,EAAQuB,MAAR,CAAvB;;AAEA,MAAIhC,MAAM,CAAC,CAAD,CAAV,EAAe;AACb,UAAMA,MAAM,CAAC,CAAD,CAAZ;AACD;AACF;AAED;;;;SAIgBkC,OAAUzB,OAAgBuB;AACxC,QAAMG,GAAG,GAAGH,MAAM,CAACxB,OAAP,CAAeC,KAAf,CAAZ;AACAsB,EAAAA,MAAM,CAACI,GAAD,EAAMH,MAAN,CAAN;AACA,SAAOG,GAAP;AACD;AAED;;;;SAIgBC,GAAM3B,OAAgBuB;AACpC,QAAMhC,MAAM,GAAGiC,QAAQ,CAACxB,KAAD,EAAQuB,MAAR,CAAvB;AACA,SAAO,CAAChC,MAAM,CAAC,CAAD,CAAd;AACD;AAED;;;;SAIgBiC,SACdxB,OACAuB,QACAK,WAAoB;AAEpB,MAAIA,QAAJ,EAAc;AACZ5B,IAAAA,KAAK,GAAGuB,MAAM,CAACxB,OAAP,CAAeC,KAAf,CAAR;AACD;;AAED,QAAMM,QAAQ,GAAGuB,KAAK,CAAC7B,KAAD,EAAQuB,MAAR,CAAtB;AACA,QAAM,CAAClB,OAAD,IAAYC,QAAlB;;AAEA,MAAID,OAAJ,EAAa;AACX,UAAMyB,KAAK,GAAG,IAAI3B,WAAJ,CAAgBE,OAAhB,EAAyBC,QAAzB,CAAd;AACA,WAAO,CAACwB,KAAD,EAAQC,SAAR,CAAP;AACD,GAHD,MAGO;AACL,WAAO,CAACA,SAAD,EAAY/B,KAAZ,CAAP;AACD;AACF;AAED;;;;AAIA,UAAU6B,KAAV,CACE7B,KADF,EAEEuB,MAFF,EAGEhB,OAAc,EAHhB,EAIEC,SAAgB,EAJlB;AAME,QAAM;AAAEX,IAAAA;AAAF,MAAW0B,MAAjB;AACA,QAAMS,GAAG,GAAkB;AACzBhC,IAAAA,KADyB;AAEzBH,IAAAA,IAFyB;AAGzBW,IAAAA,MAHyB;AAIzBD,IAAAA,IAJyB;;AAKzBd,IAAAA,IAAI,CAACG,KAAK,GAAG,EAAT;AACF;AAASI,QAAAA,KAAT;AAAgBH,QAAAA,IAAhB;AAAsBU,QAAAA,IAAtB;AAA4BC,QAAAA,MAAM,EAAE,CAAC,GAAGA,MAAJ,EAAYR,KAAZ;AAApC,SAA2DJ,KAA3D;AACD,KAPwB;;AAQzBiC,IAAAA,KAAK,CAACI,CAAD,EAAIC,CAAJ,EAAOC,MAAP,EAAeC,GAAf;AACH,YAAMC,CAAC,GAAGF,MAAM,KAAKJ,SAAX,GAAuB,CAAC,GAAGxB,IAAJ,EAAU6B,GAAV,CAAvB,GAAwC7B,IAAlD;AACA,YAAM+B,CAAC,GAAGH,MAAM,KAAKJ,SAAX,GAAuB,CAAC,GAAGvB,MAAJ,EAAY2B,MAAZ,CAAvB,GAA6C3B,MAAvD;AACA,aAAOqB,KAAK,CAACI,CAAD,EAAIC,CAAJ,EAAOG,CAAP,EAAUC,CAAV,CAAZ;AACD;;AAZwB,GAA3B;AAeA,QAAMvB,QAAQ,GAAGzB,UAAU,CAACiC,MAAM,CAACtB,SAAP,CAAiBD,KAAjB,EAAwBgC,GAAxB,CAAD,EAA+BA,GAA/B,CAA3B;AACA,QAAM,CAAC3B,OAAD,IAAYU,QAAlB;;AAEA,MAAIV,OAAJ,EAAa;AACX,UAAMA,OAAN;AACA,WAAOU,QAAP;AACD,GAHD,MAGO;AACL,WAAOzB,UAAU,CAACiC,MAAM,CAACrB,OAAP,CAAeF,KAAf,EAA2BgC,GAA3B,CAAD,EAAkCA,GAAlC,CAAjB;AACD;AACF;;ACjND;;;;SAIgBO,SACdhB,QACAxB;AAEA,QAAMyC,EAAE,GAAGjB,MAAM,CAACxB,OAAlB;AACA,SAAO,IAAIL,MAAJ,mCACF6B,MADE;AAELxB,IAAAA,OAAO,EAAGC,KAAD;AACP,aAAOwC,EAAE,CAACzC,OAAO,CAACC,KAAD,CAAR,CAAT;AACD;AAJI,KAAP;AAMD;AAED;;;;;;;SAOgByC,UACdC,GACAC,UACAC;AAEA,SAAOL,QAAQ,CAACG,CAAD,EAAKG,CAAD;AACjB,UAAMC,CAAC,GAAG,OAAOH,QAAP,KAAoB,UAApB,GAAiCA,QAAQ,EAAzC,GAA8CA,QAAxD;;AAEA,QAAIE,CAAC,KAAKd,SAAV,EAAqB;AACnB,aAAOe,CAAP;AACD;;AAED,QAAIF,MAAM,KAAK,IAAX,IAAmBG,aAAa,CAACF,CAAD,CAAhC,IAAuCE,aAAa,CAACD,CAAD,CAAxD,EAA6D;AAC3D,YAAMpB,GAAG,sBAAQmB,CAAR,CAAT;;AACA,UAAIG,OAAO,GAAG,KAAd;;AAEA,WAAK,MAAMZ,GAAX,IAAkBU,CAAlB,EAAqB;AACnB,YAAIpB,GAAG,CAACU,GAAD,CAAH,KAAaL,SAAjB,EAA4B;AAC1BL,UAAAA,GAAG,CAACU,GAAD,CAAH,GAAWU,CAAC,CAACV,GAAD,CAAZ;AACAY,UAAAA,OAAO,GAAG,IAAV;AACD;AACF;;AAED,UAAIA,OAAJ,EAAa;AACX,eAAOtB,GAAP;AACD;AACF;;AAED,WAAOmB,CAAP;AACD,GAxBc,CAAf;AAyBD;AAED;;;;SAIgBI,OAGdP;AACA,SAAOH,QAAQ,CAACG,CAAD,EAAKG,CAAD;AACjB,QAAI,CAACE,aAAa,CAACF,CAAD,CAAlB,EAAuB;AACrB,aAAOA,CAAP;AACD;;AAED,UAAMnB,GAAG,GAAQ,EAAjB;;AAEA,SAAK,MAAMU,GAAX,IAAkBM,CAAC,CAAC5C,MAApB,EAA4B;AAC1B4B,MAAAA,GAAG,CAACU,GAAD,CAAH,GAAWS,CAAC,CAACT,GAAD,CAAZ;AACD;;AAED,WAAOV,GAAP;AACD,GAZc,CAAf;AAaD;AAED;;;;AAIA,SAASqB,aAAT,CAAuB/C,KAAvB;AACE,MAAIgB,MAAM,CAACK,SAAP,CAAiB6B,QAAjB,CAA0BC,IAA1B,CAA+BnD,KAA/B,MAA0C,iBAA9C,EAAiE;AAC/D,WAAO,KAAP;AACD;;AAED,QAAMqB,SAAS,GAAGL,MAAM,CAACoC,cAAP,CAAsBpD,KAAtB,CAAlB;AACA,SAAOqB,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKL,MAAM,CAACK,SAAlD;AACD;;ACzFD;;;;SAIgBgC,MAAgCX;AAC9C,SAAOY,UAAU,CAACZ,CAAD,KAAOA,CAAC,CAAC7C,cAAT,EAA0BG,KAAD;AACxC,WAAOA,KAAK,CAACW,MAAN,KAAiB,CAAxB;AACD,GAFgB,CAAjB;AAGD;AAED;;;;;SAKgBA,OACd+B,GACAa,KACAC;AAEA,SAAOF,UAAU,CAACZ,CAAD,KAAOA,CAAC,CAAC7C,iBAAiB0D,OAAOC,MAAjC,EAA0CxD,KAAD;AACxD,WAAOuD,GAAG,GAAGvD,KAAK,CAACW,MAAZ,IAAsBX,KAAK,CAACW,MAAN,GAAe6C,GAA5C;AACD,GAFgB,CAAjB;AAGD;AAED;;;;SAIgBC,QACdf,GACAgB;AAEA,SAAOJ,UAAU,CAACZ,CAAD,KAAOA,CAAC,CAAC7C,kBAAkB6D,MAAM,CAACC,SAAlC,EAA8C3D,KAAD;AAC5D,WAAO0D,MAAM,CAACE,IAAP,CAAY5D,KAAZ,CAAP;AACD,GAFgB,CAAjB;AAGD;AAED;;;;SAIgBsD,WACd/B,QACA1B,MACAK;AAEA,QAAMsC,EAAE,GAAGjB,MAAM,CAACrB,OAAlB;AACA,SAAO,IAAIR,MAAJ,mCACF6B,MADE;AAEL1B,IAAAA,IAFK;;AAGL,KAACK,OAAD,CAASF,KAAT,EAAgBP,IAAhB;AACE,aAAOH,UAAU,CAACkD,EAAE,CAACxC,KAAD,EAAQP,IAAR,CAAH,EAAkBA,IAAlB,CAAjB;AACA,aAAOH,UAAU,CAACY,OAAO,CAACF,KAAD,EAAQP,IAAR,CAAR,EAAuBA,IAAvB,CAAjB;AACD;;AANI,KAAP;AAQD;;ACxDD;;;;SAIgBoE;AACd,SAAOtC,MAAM,CAAC,KAAD,EAAQ,MAAM,IAAd,CAAb;AACD;SAQeuC,MAASC;AACvB,SAAO,IAAIrE,MAAJ,CAAW;AAChBG,IAAAA,IAAI,WAAWkE,OAAO,GAAGA,OAAO,CAAClE,IAAX,GAAkB,YADxB;AAEhBC,IAAAA,MAAM,EAAEiE,OAFQ;AAGhBhE,IAAAA,OAAO,EAAGC,KAAD;AACP,aAAO+D,OAAO,IAAIC,KAAK,CAACC,OAAN,CAAcjE,KAAd,CAAX,GACHA,KAAK,CAACkE,GAAN,CAAWjC,CAAD,IAAOR,MAAM,CAACQ,CAAD,EAAI8B,OAAJ,CAAvB,CADG,GAEH/D,KAFJ;AAGD,KAPe;;AAQhB,KAACC,SAAD,CAAWD,KAAX,EAAkBgC,GAAlB;AACE,UAAI,CAACgC,KAAK,CAACC,OAAN,CAAcjE,KAAd,CAAL,EAA2B;AACzB,cAAMgC,GAAG,CAACvC,IAAJ,EAAN;AACA;AACD;;AAED,UAAIsE,OAAJ,EAAa;AACX,aAAK,MAAM,CAACI,CAAD,EAAIlC,CAAJ,CAAX,IAAqBjC,KAAK,CAACoE,OAAN,EAArB,EAAsC;AACpC,iBAAOpC,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAa8B,OAAb,EAAsB/D,KAAtB,EAA6BmE,CAA7B,CAAP;AACD;AACF;AACF;;AAnBe,GAAX,CAAP;AAqBD;AAED;;;;SAIgBE;AACd,SAAO9C,MAAM,CAAC,SAAD,EAAavB,KAAD;AACvB,WAAO,OAAOA,KAAP,KAAiB,SAAxB;AACD,GAFY,CAAb;AAGD;AAED;;;;;;;SAOgBsE;AACd,SAAO/C,MAAM,CAAC,MAAD,EAAUvB,KAAD;AACpB,WAAOA,KAAK,YAAYuE,IAAjB,IAAyB,CAACC,KAAK,CAACxE,KAAK,CAACyE,OAAN,EAAD,CAAtC;AACD,GAFY,CAAb;AAGD;AAED;;;;SAIgBC,QACdlC;AAEA,SAAOjB,MAAM,CAAC,cAAD,EAAiB,CAACvB,KAAD,EAAQgC,GAAR;AAC5B,WAAOA,GAAG,CAACH,KAAJ,CAAU7B,KAAV,EAAiBwC,EAAE,CAACxC,KAAD,EAAQgC,GAAR,CAAnB,CAAP;AACD,GAFY,CAAb;AAGD;SAQe2C,MAASC;AACvB,SAAOrD,MAAM,SAASqD,MAAM,CAACV,GAAP,CAAWW,eAAX,IAAT,EAA0C7E,KAAD;AACpD,WAAO4E,MAAM,CAACE,QAAP,CAAgB9E,KAAhB,CAAP;AACD,GAFY,CAAb;AAGD;AAED;;;;SAIgB+E;AACd,SAAOxD,MAAM,CAAC,UAAD,EAAcvB,KAAD;AACxB,WAAO,OAAOA,KAAP,KAAiB,UAAxB;AACD,GAFY,CAAb;AAGD;AAED;;;;SAIgBgF,SACdC;AAEA,SAAO1D,MAAM,eAAe0D,KAAK,CAACC,OAArB,EAA+BlF,KAAD;AACzC,WAAOA,KAAK,YAAYiF,KAAxB;AACD,GAFY,CAAb;AAGD;SAqDeE,aAAaC;AAC3B,SAAO7D,MAAM,CAAC6D,OAAO,CAAClB,GAAR,CAAahC,CAAD,IAAOA,CAAC,CAACrC,IAArB,EAA2Be,IAA3B,CAAgC,KAAhC,CAAD,EAAyC,WAAWZ,KAAX,EAAkBgC,GAAlB;AACpD,SAAK,MAAMU,CAAX,IAAgB0C,OAAhB,EAAyB;AACvB,aAAOpD,GAAG,CAACH,KAAJ,CAAU7B,KAAV,EAAiB0C,CAAjB,CAAP;AACD;AACF,GAJY,CAAb;AAKD;AAED;;;;;;SAMgB2C,KAAQ7C;AACtB,MAAIE,CAAJ;AAEA,SAAOnB,MAAM,CAAC,WAAD,EAAc,CAACvB,KAAD,EAAQgC,GAAR;AACzB,QAAI,CAACU,CAAL,EAAQ;AACNA,MAAAA,CAAC,GAAGF,EAAE,EAAN;AACD;;AAED,WAAOR,GAAG,CAACH,KAAJ,CAAU7B,KAAV,EAAiB0C,CAAjB,CAAP;AACD,GANY,CAAb;AAOD;SAUe4C,QAAWC;AACzB,SAAOhE,MAAM,YAAYsD,eAAe,CAACU,QAAD,IAA3B,EAA2CvF,KAAD;AACrD,WAAOA,KAAK,KAAKuF,QAAjB;AACD,GAFY,CAAb;AAGD;AAED;;;;SAIgBrB,IAAUsB,KAAgBC;AACxC,SAAOlE,MAAM,QAAQiE,GAAG,CAAC3F,QAAQ4F,KAAK,CAAC5F,OAA1B,EAAmC,WAAWG,KAAX,EAAkBgC,GAAlB;AAC9C,QAAI,EAAEhC,KAAK,YAAY0F,GAAnB,CAAJ,EAA6B;AAC3B,YAAM1D,GAAG,CAACvC,IAAJ,EAAN;AACA;AACD;;AAED,SAAK,MAAM,CAACkG,CAAD,EAAI1D,CAAJ,CAAX,IAAqBjC,KAAK,CAACoE,OAAN,EAArB,EAAsC;AACpC,aAAOpC,GAAG,CAACH,KAAJ,CAAU8D,CAAV,EAAaH,GAAb,EAAkBxF,KAAlB,EAAyB2F,CAAzB,CAAP;AACA,aAAO3D,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAawD,KAAb,EAAoBzF,KAApB,EAA2B2F,CAA3B,CAAP;AACD;AACF,GAVY,CAAb;AAWD;AAED;;;;SAIgBC;AACd,SAAOrE,MAAM,CAAC,OAAD,EAAU,MAAM,KAAhB,CAAb;AACD;AAED;;;;SAIgBsE,SAAYnD;AAC1B,SAAO,IAAIhD,MAAJ,CAAW;AAChBG,IAAAA,IAAI,KAAK6C,CAAC,CAAC7C,aADK;AAEhBC,IAAAA,MAAM,EAAE4C,CAAC,CAAC5C,MAFM;AAGhBG,IAAAA,SAAS,EAAE,CAACD,KAAD,EAAQgC,GAAR;AACT,aAAOhC,KAAK,KAAK,IAAV,IAAkBgC,GAAG,CAACH,KAAJ,CAAU7B,KAAV,EAAiB0C,CAAjB,CAAzB;AACD;AALe,GAAX,CAAP;AAOD;AAED;;;;SAIgBoD;AACd,SAAOvE,MAAM,SAAA,EAAYvB,KAAD;AACtB,WAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAACwE,KAAK,CAACxE,KAAD,CAA1C;AACD,GAFY,CAAb;AAGD;SA2Ce+F,OACdX;AAEA,QAAMY,MAAM,GAAGZ,OAAO,GAAGpE,MAAM,CAACiF,IAAP,CAAYb,OAAZ,CAAH,GAA0B,EAAhD;AACA,QAAMc,KAAK,GAAGN,KAAK,EAAnB;AACA,SAAO,IAAIlG,MAAJ,CAAW;AAChBG,IAAAA,IAAI,EAAEuF,OAAO,cAAcY,MAAM,CAACpF,IAAP,CAAY,GAAZ,KAAd,GAAqC,QADlC;AAEhBd,IAAAA,MAAM,EAAEsF,OAAO,GAAGA,OAAH,GAAa,IAFZ;AAGhBrF,IAAAA,OAAO,EAAEqF,OAAO,GAAGe,mBAAmB,CAACf,OAAD,CAAtB,GAAmCvC,CAAD,IAAOA,CAHzC;;AAIhB,KAAC5C,SAAD,CAAWD,KAAX,EAAkBgC,GAAlB;AACE,UAAI,OAAOhC,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAA1C,EAAgD;AAC9C,cAAMgC,GAAG,CAACvC,IAAJ,EAAN;AACA;AACD;;AAED,UAAI2F,OAAJ,EAAa;AACX,cAAMgB,QAAQ,GAAG,IAAIC,GAAJ,CAAQrF,MAAM,CAACiF,IAAP,CAAYjG,KAAZ,CAAR,CAAjB;;AAEA,aAAK,MAAMoC,GAAX,IAAkB4D,MAAlB,EAA0B;AACxBI,UAAAA,QAAQ,CAACE,MAAT,CAAgBlE,GAAhB;AACA,gBAAMqD,KAAK,GAAGL,OAAO,CAAChD,GAAD,CAArB;AACA,gBAAMH,CAAC,GAAGjC,KAAK,CAACoC,GAAD,CAAf;AACA,iBAAOJ,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAawD,KAAb,EAAoBzF,KAApB,EAA2BoC,GAA3B,CAAP;AACD;;AAED,aAAK,MAAMA,GAAX,IAAkBgE,QAAlB,EAA4B;AAC1B,gBAAMnE,CAAC,GAAGjC,KAAK,CAACoC,GAAD,CAAf;AACA,iBAAOJ,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAaiE,KAAb,EAAoBlG,KAApB,EAA2BoC,GAA3B,CAAP;AACD;AACF;AACF;;AAzBe,GAAX,CAAP;AA2BD;AAED;;;;SAIgBmE,SAAY7D;AAC1B,SAAO,IAAIhD,MAAJ,CAAW;AAChBG,IAAAA,IAAI,KAAK6C,CAAC,CAAC7C,OADK;AAEhBC,IAAAA,MAAM,EAAE4C,CAAC,CAAC5C,MAFM;AAGhBG,IAAAA,SAAS,EAAE,CAACD,KAAD,EAAQgC,GAAR;AACT,aAAOhC,KAAK,KAAK+B,SAAV,IAAuBC,GAAG,CAACH,KAAJ,CAAU7B,KAAV,EAAiB0C,CAAjB,CAA9B;AACD;AALe,GAAX,CAAP;AAOD;AAED;;;;SAIgB8D,QACdpB;AAEA,MAAIA,OAAO,YAAY1F,MAAvB,EAA+B;AAC7B0F,IAAAA,OAAO,GAAGA,OAAO,CAACtF,MAAlB;AACD;;AAED,QAAMkG,MAAM,GAAGhF,MAAM,CAACiF,IAAP,CAAYb,OAAZ,CAAf;AACA,QAAMc,KAAK,GAAGN,KAAK,EAAnB;AACA,SAAO,IAAIlG,MAAJ,CAAW;AAChBG,IAAAA,IAAI,cAAcmG,MAAM,CAACpF,IAAP,CAAY,GAAZ,KADF;AAEhBd,IAAAA,MAAM,EAAEsF,OAFQ;AAGhBrF,IAAAA,OAAO,EAAEoG,mBAAmB,CAACf,OAAD,CAHZ;;AAIhB,KAACnF,SAAD,CAAWD,KAAX,EAAkBgC,GAAlB;AACE,UAAI,OAAOhC,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAA1C,EAAgD;AAC9C,cAAMgC,GAAG,CAACvC,IAAJ,EAAN;AACA;AACD;;AAED,YAAM2G,QAAQ,GAAG,IAAIC,GAAJ,CAAQrF,MAAM,CAACiF,IAAP,CAAYjG,KAAZ,CAAR,CAAjB;;AAEA,WAAK,MAAMoC,GAAX,IAAkB4D,MAAlB,EAA0B;AACxBI,QAAAA,QAAQ,CAACE,MAAT,CAAgBlE,GAAhB;;AAEA,YAAI,EAAEA,GAAG,IAAIpC,KAAT,CAAJ,EAAqB;AACnB;AACD;;AAED,cAAMyF,KAAK,GAAGL,OAAO,CAAChD,GAAD,CAArB;AACA,cAAMH,CAAC,GAAGjC,KAAK,CAACoC,GAAD,CAAf;AACA,eAAOJ,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAawD,KAAb,EAAoBzF,KAApB,EAA2BoC,GAA3B,CAAP;AACD;;AAED,WAAK,MAAMA,GAAX,IAAkBgE,QAAlB,EAA4B;AAC1B,cAAMnE,CAAC,GAAGjC,KAAK,CAACoC,GAAD,CAAf;AACA,eAAOJ,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAaiE,KAAb,EAAoBlG,KAApB,EAA2BoC,GAA3B,CAAP;AACD;AACF;;AA5Be,GAAX,CAAP;AA8BD;AAED;;;;;SAKgBqE,OACdjB,KACAC;AAEA,SAAOlE,MAAM,WAAWiE,GAAG,CAAC3F,QAAQ4F,KAAK,CAAC5F,OAA7B,EAAsC,WAAWG,KAAX,EAAkBgC,GAAlB;AACjD,QAAI,OAAOhC,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAA1C,EAAgD;AAC9C,YAAMgC,GAAG,CAACvC,IAAJ,EAAN;AACA;AACD;;AAED,SAAK,MAAMkG,CAAX,IAAgB3F,KAAhB,EAAuB;AACrB,YAAMiC,CAAC,GAAGjC,KAAK,CAAC2F,CAAD,CAAf;AACA,aAAO3D,GAAG,CAACH,KAAJ,CAAU8D,CAAV,EAAaH,GAAb,EAAkBxF,KAAlB,EAAyB2F,CAAzB,CAAP;AACA,aAAO3D,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAawD,KAAb,EAAoBzF,KAApB,EAA2B2F,CAA3B,CAAP;AACD;AACF,GAXY,CAAb;AAYD;AAED;;;;SAIgBe,IAAO3C;AACrB,SAAOxC,MAAM,QAAQwC,OAAO,CAAClE,OAAhB,EAAyB,CAACG,KAAD,EAAQgC,GAAR;AACpC,QAAI,EAAEhC,KAAK,YAAYqG,GAAnB,CAAJ,EAA6B;AAC3B,aAAO,KAAP;AACD;;AAED,SAAK,MAAMM,GAAX,IAAkB3G,KAAlB,EAAyB;AACvB,YAAM,CAACK,OAAD,IAAY2B,GAAG,CAACH,KAAJ,CAAU8E,GAAV,EAAe5C,OAAf,CAAlB;;AAEA,UAAI1D,OAAJ,EAAa;AACX,eAAO,KAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD,GAdY,CAAb;AAeD;AAED;;;;SAIgBuG;AACd,SAAOrF,MAAM,CAAC,QAAD,EAAYvB,KAAD;AACtB,WAAO,OAAOA,KAAP,KAAiB,QAAxB;AACD,GAFY,CAAb;AAGD;AAED;;;;SAIgBuB,OACd2D,MACAjF;AAEA,SAAO,IAAIP,MAAJ,CAAW;AAAEG,IAAAA,IAAI,EAAEqF,IAAR;AAAcjF,IAAAA,SAAd;AAAyBH,IAAAA,MAAM,EAAE;AAAjC,GAAX,CAAP;AACD;SAqDe+G,MAAMC;AACpB,QAAMZ,KAAK,GAAGN,KAAK,EAAnB;AAEA,SAAOrE,MAAM,KAAKuF,QAAQ,CAAC5C,GAAT,CAAchC,CAAD,IAAOA,CAAC,CAACrC,IAAtB,EAA4Be,IAA5B,CAAiC,GAAjC,IAAL,EAA+C,WAC1DZ,KAD0D,EAE1DgC,GAF0D;AAI1D,QAAI,CAACgC,KAAK,CAACC,OAAN,CAAcjE,KAAd,CAAL,EAA2B;AACzB,YAAMgC,GAAG,CAACvC,IAAJ,EAAN;AACA;AACD;;AAED,SAAK,MAAM,CAACsH,KAAD,EAAQhD,OAAR,CAAX,IAA+B+C,QAAQ,CAAC1C,OAAT,EAA/B,EAAmD;AACjD,YAAMnC,CAAC,GAAGjC,KAAK,CAAC+G,KAAD,CAAf;AACA,aAAO/E,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAa8B,OAAb,EAAsB/D,KAAtB,EAA6B+G,KAA7B,CAAP;AACD;;AAED,QAAI/G,KAAK,CAACW,MAAN,GAAemG,QAAQ,CAACnG,MAA5B,EAAoC;AAClC,YAAMoG,KAAK,GAAGD,QAAQ,CAACnG,MAAvB;AACA,YAAMsB,CAAC,GAAGjC,KAAK,CAAC+G,KAAD,CAAf;AACA,aAAO/E,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAaiE,KAAb,EAAoBlG,KAApB,EAA2B+G,KAA3B,CAAP;AACD;AACF,GAnBY,CAAb;AAoBD;AAED;;;;;SAKgBlH,KACduF;AAEA,QAAMa,IAAI,GAAGjF,MAAM,CAACiF,IAAP,CAAYb,OAAZ,CAAb;AAEA,SAAO7D,MAAM,UAAU0E,IAAI,CAACrF,IAAL,CAAU,GAAV,KAAV,EAA8B,WAAWZ,KAAX,EAAkBgC,GAAlB;AACzC,QAAI,OAAOhC,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAA1C,EAAgD;AAC9C,YAAMgC,GAAG,CAACvC,IAAJ,EAAN;AACA;AACD;;AAED,SAAK,MAAM2C,GAAX,IAAkB6D,IAAlB,EAAwB;AACtB,YAAMR,KAAK,GAAGL,OAAO,CAAChD,GAAD,CAArB;AACA,YAAMH,CAAC,GAAIjC,KAAa,CAACoC,GAAD,CAAxB;AACA,aAAOJ,GAAG,CAACH,KAAJ,CAAUI,CAAV,EAAawD,KAAb,EAAoBzF,KAApB,EAA2BoC,GAA3B,CAAP;AACD;AACF,GAXY,CAAb;AAYD;SAqDe4E,MAAM5B;AACpB,SAAO7D,MAAM,IAAI6D,OAAO,CAAClB,GAAR,CAAahC,CAAD,IAAOA,CAAC,CAACrC,IAArB,EAA2Be,IAA3B,CAAgC,KAAhC,GAAJ,EAA8C,WACzDZ,KADyD,EAEzDgC,GAFyD;AAIzD,SAAK,MAAMU,CAAX,IAAgB0C,OAAhB,EAAyB;AACvB,YAAM,CAAC,GAAGrE,QAAJ,IAAgBiB,GAAG,CAACH,KAAJ,CAAU7B,KAAV,EAAiB0C,CAAjB,CAAtB;;AAEA,UAAI3B,QAAQ,CAACJ,MAAT,KAAoB,CAAxB,EAA2B;AACzB;AACD;AACF;;AAED,UAAMqB,GAAG,CAACvC,IAAJ,EAAN;AACD,GAbY,CAAb;AAcD;AAED;;;;AAIA,SAASoF,eAAT,CAAyB7E,KAAzB;AACE,SAAO,OAAOA,KAAP,KAAiB,QAAjB,OACCA,KAAK,CAACiH,OAAN,CAAc,IAAd,EAAoB,GAApB,IADD,MAEAjH,OAFP;AAGD;AAED;;;;;AAIA,SAASmG,mBAAT,CACEf,OADF;AAGE,QAAMY,MAAM,GAAGhF,MAAM,CAACiF,IAAP,CAAYb,OAAZ,CAAf;AAEA,SAAQpF,KAAD;AACL,QAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,IAA1C,EAAgD;AAC9C,aAAOA,KAAP;AACD;;AAED,UAAM0B,GAAG,GAAG,EAAZ;AACA,UAAM0E,QAAQ,GAAG,IAAIC,GAAJ,CAAQrF,MAAM,CAACiF,IAAP,CAAYjG,KAAZ,CAAR,CAAjB;;AAEA,SAAK,MAAMoC,GAAX,IAAkB4D,MAAlB,EAA0B;AACxBI,MAAAA,QAAQ,CAACE,MAAT,CAAgBlE,GAAhB;AACA,YAAMqD,KAAK,GAAGL,OAAO,CAAChD,GAAD,CAArB;AACA,YAAMH,CAAC,GAAGjC,KAAK,CAACoC,GAAD,CAAf;AACAV,MAAAA,GAAG,CAACU,GAAD,CAAH,GAAWX,MAAM,CAACQ,CAAD,EAAIwD,KAAJ,CAAjB;AACD;;AAED,SAAK,MAAMrD,GAAX,IAAkBgE,QAAlB,EAA4B;AAC1B1E,MAAAA,GAAG,CAACU,GAAD,CAAH,GAAWpC,KAAK,CAACoC,GAAD,CAAhB;AACD;;AAED,WAAOV,GAAP;AACD,GApBD;AAqBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}